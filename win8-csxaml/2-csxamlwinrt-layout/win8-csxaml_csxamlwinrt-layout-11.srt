1
00:00:00,310 --> 00:00:05,432
‫بسیاری برنامه‌ها نیاز دارند انبوهی از اطلاعات را
‫نمایش دهند که عموما به سختی در
‫یک صفحه جا می‌شوند.

2
00:00:05,780 --> 00:00:12,348
‫برای نمونه مثال قبلی من لیست تمام
‫تصاویر موجود در کتابخانه تصاویر من را
‫نمایش می‌داد.

3
00:00:12,352 --> 00:00:16,149
‫روش متداول حل این مساله ارائه نوعی
‫Scrolling یا لیست‌های لغزشی می‌باشد.

4
00:00:16,465 --> 00:00:18,782
‫و کنترل لیست می‌تواند اینکار را
‫برای شما انجام دهد.

5
00:00:18,915 --> 00:00:22,836
‫در مثال مرورگر تصاویر من، این عملیات
‫لغزش به کمک کنترل توکار لیست
‫میسر ‫شد.

6
00:00:23,161 --> 00:00:25,554
‫و در اغلب موارد این کاری است
‫که شما می‌خواهید انجام دهید.

7
00:00:25,944 --> 00:00:30,966
‫یکی از مهم‌ترین دلایل نیاز به
‫نوعی لغزش و scroll در صفحه، نمایش
‫لیستی از عناصر می‌باشد.

8
00:00:31,369 --> 00:00:34,515
‫ما در ماژول بعدی به کنترل لیست
‫خواهیم پرداخت.

9
00:00:34,803 --> 00:00:39,211
‫هرچند لیست‌ها تنها مواردی نیستند که
‫نیاز به لغزش و scroll دارند.

10
00:00:39,282 --> 00:00:42,444
‫بنابراین XAML کنترل ScrollViewer را ارائه داده
‫است…

11
00:00:42,615 --> 00:00:45,112
‫که توسط آن می‌توان هر قسمتی
‫از یک محتوا را قابل لغزش کرد.

12
00:00:45,438 --> 00:00:50,235
‫استفاده از آن بسیار ساده است و
‫هر شیء XAML ایی را می‌توان
‫در آن محصور کرد.

13
00:00:50,508 --> 00:00:56,681
‫از کنترل ScrollViewer می‌توان جهت محصور
‫سازی تصاویر، StackPanel و هر شیءایی که
‫علاقمند بودید استفاده کرد و سپس این کنترل
‫تمام کار را برای شما انجام خواهد داد.

14
00:00:56,684 --> 00:01:04,117
‫این کنترل به صورت خودکار محتوا را
‫به افستی مشخص لغزانده و قسمت قابل
‫دید آن را نمایان می‌کند.

15
00:01:04,385 --> 00:01:07,570
‫بنابراین برای مدیریت لغزش، نیاز به هیچگونه
‫کدنویسی نیست.

16
00:01:07,982 --> 00:01:12,497
‫همچنین این کنترل یک سری قابلیت‌های
‫تعاملی را نیز ارائه می‌دهد…

17
00:01:12,837 --> 00:01:25,252
‫برای مثال به صورت خودکار یک scrollbar
‫قابل مدیریت توسط ماوس را ارائه می‌‫دهد
‫و این عملیات را با توجه ‫به ویژگی‌های
‫طراحی مترو، زمانیکه ماوس
‫در این ناحیه قرار گیرد، نمایان می‌‫سازد و
‫در غیراینصورت اسکرول بار مخفی خواهد بود.

18
00:01:25,586 --> 00:01:34,649
‫همچنین عملیات لغزشی آن به کمک لمس
‫صفحه نیز قابل مدیریت است و حرکت
‫یکنواخت و طبیعی را سبب خواهد شد.

19
00:01:34,739 --> 00:01:54,617
‫یکی دیگر از قابلیت‌های تعاملی این
‫کنترل، Rails نام دارد که مانند ریل‫های
‫قطار حرکت یکنواختی را در سطح
‫افقی یا عمودی میسر می‌سازد و به صورت
‫موقت تنها حرکت در یک جهت را ممکن می‌کند.

20
00:01:54,803 --> 00:01:59,682
‫و این قابلیت خوبی است زیاد گاهی
‫از اوقات استفاده از اسکرول بار کمی
‫آشفته به نظر می‌رسد.

21
00:01:59,862 --> 00:02:09,143
‫این کنترل به همراه قابلیت‌های Zoom
‫و همچنین Snap points ارائه شده است.

22
00:02:09,523 --> 00:02:17,277
‫که توسط آن می‌توان یک سری
‫نقاط مورد علاقه را مشخص ساخت مانند
‫detents ‫در دنیای فیزیک

23
00:02:17,466 --> 00:02:28,247
‫برای مثال اگر درب یک خودرو را تا حدی
‫باز کنیم، در یک نقطه ثابت
‫باقی می‌ماند حتی اگر شروع به حرکت کنیم.

24
00:02:28,479 --> 00:02:37,141
‫همچنین اگر درب را بیشتر باز کنیم،
‫مجددا در همان نقطه دوم ثابت خواهد ‫شد.

25
00:02:37,185 --> 00:02:41,347
‫به این نقاط چسبناک detents گفته می‌شود.

26
00:02:41,756 --> 00:02:45,865
‫و snap points همینکار را برای کنترل
‫ScrollViewer در صفحه انجام می‌دهند.

27
00:02:46,267 --> 00:02:57,701
‫به این ترتیب می‌توان به XAML
‫گفت که بجای امکان حرکت لغزشی آزادانه،
‫می خواهیم لغزش در نقطه ای خاص
‫پایان یابد.

28
00:02:57,756 --> 00:03:00,426
‫به این ترتیب برنامه اندکی دلپذیرتر به
‫نظر خواهد رسید.

29
00:03:00,813 --> 00:03:07,879
‫همچنین کنترل ScrollViewer حاوی
‫قواعدی است که رفتار آن را حین
‫محصور شدن درون سایر کنترل‌ها یا
‫اشیاء مشابه مشخص می‌سازد.

30
00:03:07,975 --> 00:03:11,030
‫و طوری رفتار خواهد کرد که منطقی
‫به نظر برسد.

31
00:03:11,124 --> 00:03:20,498
‫البته بدیهی است که می‌توان با
‫چیدمانی غیرمنطقی این نظم را به هم
‫ریخت اما در اکثر موارد کار صحیح
‫را انجام خواهد داد.

