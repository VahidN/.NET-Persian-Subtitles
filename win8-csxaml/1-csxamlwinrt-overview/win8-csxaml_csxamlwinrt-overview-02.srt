1
00:00:00,310 --> 00:00:03,372
‫یکی از مهم‌ترین اهداف طراحی
‫برنامه‌های مترو…

2
00:00:03,585 --> 00:00:07,165
‫این است که باید نسبت به ورودهای
‫کاربری بسیار responsive باشند.

3
00:00:07,354 --> 00:00:09,493
‫حتی در سیستم هایی با توانایی‌های ‫سخت
‫افزاری پایین و محدود.

4
00:00:09,853 --> 00:00:14,925
‫به عبارتی این نوع برنامه‌های باید
‫اصطلاحا Fast & Fluid (سریع و روان)
‫باشند.

5
00:00:15,308 --> 00:00:17,996
‫معنای سریع که مشخص است…

6
00:00:18,223 --> 00:00:19,738
‫اما روان به چه معنایی است؟

7
00:00:20,031 --> 00:00:25,849
‫وسایل دارای صفحات لمسی عموما دارای محتوا
‫و امکاناتی هستند که در طول صفحه
‫کشیده می‌شوند.

8
00:00:26,015 --> 00:00:33,292
‫مانند لیست و گرید که در ماژولهای
‫دیگر به آن‌ها خواهیم رسید تا
‫صفحهٔ آغازین ویندوز.

9
00:00:33,675 --> 00:00:41,252
‫این حرکت‌ها باید طبیعی و نرم
‫و یکنواخت و خوب روغنکاری شده باشند!

10
00:00:41,538 --> 00:00:43,381
‫که به این، روان (Fluid) نیز گفته
‫می شود.

11
00:00:43,417 --> 00:00:47,376
‫و رسیدن به این هدف از آنچه
‫که تصور می‌شود بسیار سخت‌تر ‫است.

12
00:00:47,460 --> 00:00:52,260
‫دقیقا از زمانیکه اشیاء در طول صفحه
‫شروع به حرکت می‌کنند، زمانبندی بسیار
‫حساس می‌شود.

13
00:00:52,468 --> 00:00:56,988
‫به این معنا که باید به ازای
‫هر بار به روز رسانی صفحه، اشیاء
‫در حال حرکت مجددا ترسیم شوند.

14
00:00:57,141 --> 00:01:00,087
‫برای مثال 60 به روز رسانی در
‫ثانیه.

15
00:01:00,636 --> 00:01:06,268
‫اگر به این هدف به صورت یکدست
‫و با محاسبات دقیقی جهت حرکت
‫اشیاء صحیح برسیم…

16
00:01:06,568 --> 00:01:09,993
‫به یک احساس حرکت طبیعی خواهید رسید.

17
00:01:10,053 --> 00:01:12,523
‫اما اشتباه کردن نیز در اینجا بسیار
‫ساده است.

18
00:01:12,817 --> 00:01:16,736
‫برای مثال اندکی ناهماهنگی با صفحه…

19
00:01:16,941 --> 00:01:20,480
‫یا به روز رسانی برای مثال 70
‫بار در ثانیه یک فاجعه خواهد بود.

20
00:01:20,710 --> 00:01:27,825
‫حرکت را بسیار ناهموار جلوه می‌دهد.

21
00:01:28,085 --> 00:01:32,005
‫همچنین از دست دادن تعدادی به روز
‫رسانی صفحه نیز حرکت را بسیار بد
‫جلوه خواهد داد.

22
00:01:32,433 --> 00:01:37,235
‫پیوستگی حرکت زیر سؤال رفته و تصور
‫همواری حرکت دیگر وجود نخواهد داشت.

23
00:01:37,522 --> 00:01:41,371
‫و دیگر آنچنان روانی حرکتی را
‫نمی توان مشاهده کرد.

24
00:01:41,637 --> 00:01:50,087
‫بنابراین متوسط شصت‫ بار به روز رسانی در ثانیه
‫به تنهایی کافی نیست.
‫به همین جهت در بدترین شرایط نیز باید انتظار
‫داشت که به روز رسانی‌ها انجام
‫می شوند.

25
00:01:50,313 --> 00:01:58,261
‫به دلایلی نمی‌توانم این حرکت سریع
‫و روان را اینجا به شما نمایش
‫دهم.

26
00:01:58,530 --> 00:02:04,038
‫دلیل اول اینکه این ویدیوهای جاری به روز
‫رسانی 60 بار در ثانیه را پشتیبانی
‫نمی کنند.

27
00:02:04,179 --> 00:02:10,067
‫زیرا حجم دریافت شما را بسیار بالا
‫برده و همچنین دست آخر آنچنان تفاوتی
‫را در کیفیت نهایی ملاحظه نخواهید کرد.

28
00:02:10,426 --> 00:02:23,949
‫دوم اینکه حتی اگر اینکار را انجام دهم،
‫این به روز رسانی 60 بار در ثانیه
‫با به روز رسانی مونیتور یکی نخواهد بود.

29
00:02:23,988 --> 00:02:33,703
‫می توانم یک ویدیوی کامل را به
‫این بحث اختصاص دهم اما در کل
‫ویندوز 8 اینکار را بهتر از اسلاف
‫خود انجام می‌دهد.

30
00:02:33,833 --> 00:02:37,780
‫اما نکتهٔ اصلی اینجا است که
‫این مورد یک نیاز non trivial است.

31
00:02:37,855 --> 00:02:42,553
‫و WinRT امکانات قابل توجهی را جهت
‫برآورده شدن این نیاز تدارک دیده است.

32
00:02:42,945 --> 00:02:52,105
‫برای مثال امکانات توکار پویانمایی، تا حدی
‫که اگر ترد اصلی برنامه شما مشغول
‫گردید نیز به کار خود ادامه دهد.

33
00:02:52,260 --> 00:02:55,036
‫اما این، راه حلی جامع و کامل
‫نیست.

34
00:02:55,084 --> 00:03:01,373
‫دیر یا زود برنامه شما نیاز خواهد
‫داشت تا محتوای قابل پویانمایی را به
‫روز کند.

35
00:03:01,565 --> 00:03:08,728
‫بنابراین نیاز خواهیم داشت تا ترد اصلی
‫برنامه همواره جهت انجام امور آماده و
‫آزاد باشد.

36
00:03:09,063 --> 00:03:16,219
‫جهت نیل به این مقصود، WinRT از
‫روش مخصوص و منحصربفردی جهت
‫مدیریت رابط‌های کاربری استفاده می‌کند.

37
00:03:16,448 --> 00:03:20,939
‫Blocking API یا API ایی که در
‫ترد اصلی برنامه وقفه ایجاد می‌کند
‫یکی از مشکلات اصلی API قدیمی ویندوز
‫است.

38
00:03:21,019 --> 00:03:24,440
‫برای مثال فرض کنید که دارید اطلاعاتی
‫را از یک فایل دریافت می‌کنید.

39
00:03:24,676 --> 00:03:34,636
‫و اگر این اطلاعات در یک فایل
‫سرور قرار داشته باشد که از طریق
‫یک شبکه بی سیم در دسترس قرار
‫گرفته است، خواندن اطلاعات از آن سریع
‫نخواهد بود.

40
00:03:34,917 --> 00:03:48,965
‫روش بدوی مواجه شدن با این نوع
‫موارد وجود یک API جهت خواندن محتویات
‫فایل و بلاک کردن ترد اصلی تا
‫زمانی است که کار خواندن به پایان
‫برسد.

41
00:03:49,068 --> 00:03:55,162
‫و برای مثال اگر این اطلاعات قرار
‫است که از شبکه دریافت شود، بدون
‫شک ترد اصلی برنامه مدتی مشغول خواهد
‫بود.

42
00:03:55,549 --> 00:03:59,766
‫این طراحی بدوی و متداول جهت کار
‫با رابط کارهای نامناسب است.

43
00:03:59,918 --> 00:04:04,234
‫زیرا ترد اصلی برنامه جهت دریافت اطلاعات
‫متوقف شده و دیگر نمی‌تواند به
‫ورودی‌های کاربر پاسخ دهد.

44
00:04:04,580 --> 00:04:10,133
‫البته امکان اجتناب از این مساله نیز
‫در Win32 و دات نت نیز وجود
‫داشته است و دارد.

45
00:04:10,218 --> 00:04:12,678
‫راه حل‌های non blocking دیگر قابل
‫استفاده هستند.

46
00:04:12,850 --> 00:04:19,956
‫و یا می‌توان از تردهایی که
‫وظیفهٔ مدیریت ورودی‌های کاربری را
‫ندارند برای حل این مساله استفاده کرد.

47
00:04:20,183 --> 00:04:23,831
‫اما واقعیت این است که بسیاری از
‫برنامه‌ها از این روش‌ها استفاده
‫نمی کنند.

48
00:04:23,984 --> 00:04:26,990
‫بنابراین مشاهدهٔ برنامه هایی که به
‫ظاهر مدام هنگ می‌کنند بسیار متداول
‫است.

49
00:04:27,377 --> 00:04:39,389
‫در WinRT برای مقابله با این مساله،
‫API‌های طراحی شده مجاز نیستند که
‫بیش از 50 میلی ثانیه جهت انجام
‫امری بیشتر زمان ببرند.

50
00:04:39,496 --> 00:04:48,010
‫و هر چیزی که احتمال می‌رود
‫بیشتر از 50 میلی ثانیه طول
‫می کشد باید API غیرهمزمانی
‫را نیز ارائه دهد.

51
00:04:48,232 --> 00:04:55,648
‫به عبارتی متد باید پیش از به پایان رسیدن
‫خاتمه یافته و روشی را ارائه دهد که بتوان
‫به نتیجهٔ آن در پایان کار دسترسی یافت.

52
00:04:55,933 --> 00:05:01,581
‫WinRT الگوی استانداردی را جهت ارائهٔ
‫اعمال غیرهمزمان ارائه می‌دهد.

53
00:05:01,977 --> 00:05:06,630
‫اما به عنوان برنامه نویس سی شارپ
‫به صورت مستقیم با این مساله درگیر
‫نخواهید بود.

54
00:05:06,864 --> 00:05:11,968
‫زیرا نسخهٔ هماهنگ با دات نت
‫آن، به صورت خودکار توسط کامپایلر مورد
‫استفاده در اختیار برنامه قرار خواهد گرفت.

55
00:05:12,238 --> 00:05:15,772
‫دات نت شیوهٔ خاص خودش را
‫جهت انجام امور غیرهمزمان دارد.

56
00:05:16,159 --> 00:05:21,184
‫که حداقل شامل سه شیوه
‫مختلف می‌شود.

57
00:05:21,481 --> 00:05:25,287
‫اما ‫آخرین آن که به همراه دات 4
‫و نیم ارائه می‌شود…

58
00:05:25,363 --> 00:05:34,986
‫جهت سهولت استفاده و به کمک
‫واژه‌های کلیدی خاصی طراحی شده است
‫و در VB و سی شارپ قابل
‫استفاده هستند.

59
00:05:35,043 --> 00:05:42,142
‫و این مورد است که به صورت
‫خودکار در پشت صحنه توسط محصور
‫کننده هایی که کامپایلر تولید می‌کند
‫به معادل‌های WinRT تبدیل خواهند شد.

