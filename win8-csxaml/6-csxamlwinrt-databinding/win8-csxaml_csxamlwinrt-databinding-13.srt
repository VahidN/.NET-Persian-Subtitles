1
00:00:01,117 --> 00:00:03,671
‫محتوای لیست‌ها در زمان اجرا
‫قابل تغییر هستند

2
00:00:04,180 --> 00:00:09,777
‫و اگر این لیست را به نوعی از
‫ItemsControl‌ها Bind کرده باشیم،
‫علاقمند خواهیم بود تا این
‫تغییرات را نمایش دهیم.

3
00:00:10,605 --> 00:00:11,154
‫هرچند

4
00:00:11,434 --> 00:00:15,504
‫مکانیزم INotifyPropertyChanged را
‫که پیشتر بررسی کردیم، اینجا
‫مفید نخواهد بود.

5
00:00:16,302 --> 00:00:21,890
‫به کمک آن اینترفیس، به سیستم
‫Binding در مورد تغییرات اشیایی
‫که اطلاعاتی را در مورد آن‌ها دارد،
‫اطلاع رسانی می‌گردد.

6
00:00:22,000 --> 00:00:30,700
‫اما این سیستم چگونه اشیایی
‫کاملا جدید را که اخیرا اضافه شده اند
‫را می‌تواند تشخیص دهد؟ یا برای
‫مثال چگونه می‌تواند انتقال اشیاء در
‫یک لیست یا حذف آن‌ها را ردیابی کند؟

7
00:00:31,568 --> 00:00:35,559
‫بنابراین نیاز به اینترفیس دیگری برای
‫مدیریت تغییرات لیست‌ها خواهیم داشت.

8
00:00:36,347 --> 00:00:46,135
‫البته برنامه نویس‌های WPF و Silverlight
‫باید به یک سری موارد دقت داشته باشند؛
‫برای مثال اینترفیس
‫INotifyCollectionChanged مورد استفاده
‫در ObservableCollections فعلا

9
00:00:46,564 --> 00:00:48,779
‫در نگارش آزمایشی ویندوز 8 پشتیبانی نمی‌شود.

10
00:00:50,006 --> 00:01:01,360
‫البته باید دقت داشت که این مورد هنوز
‫در دات نت فریم ورک وجود دارد و اگر کدی
‫قدیمی را از WPF و سیلورلایت که از
‫INotifyCollectionChanged و ObservableCollections
‫استفاده می‌کند، به اینجا انتقال دهید،
‫برنامه کامپایل خواهد شد

11
00:01:01,789 --> 00:01:02,956
‫اما کار نخواهد کرد.

12
00:01:03,745 --> 00:01:12,525
‫مایکروسافت عنوان کرده است که قصد
‫دارد این مورد را پیش از ارائه نهایی
‫تغییر داده و تکمیل کند؛ بنابراین ممکن است
‫که در آینده مجددا بتوانید از ObservableCollections
‫موجود در WPF و Silverlight نیز استفاده کنید

13
00:01:12,764 --> 00:01:14,141
‫اما فعلا باید از یک نوع دیگر استفاده کرد.

14
00:01:15,418 --> 00:01:20,018
‫تنها اینترفیس با قابلیت ردیابی تغییرات
‫قابل شناسایی توسط
‫ItemsControl مهیا در WinRT

15
00:01:20,387 --> 00:01:22,652
IObservableVector of T
‫می باشد

16
00:01:23,320 --> 00:01:27,131
‫که در فضای نام
windows. foundation. collections
‫تعریف شده است.

17
00:01:28,000 --> 00:01:29,466
‫محض تفریح!

18
00:01:29,805 --> 00:01:35,762
‫نه WinRT و نه دات نت فریم ورک
‫پیاده سازی عمومی را از این
‫اینترفیس ارائه نداده اند!

19
00:01:36,460 --> 00:01:41,000
‫برای مثال ObservableCollection of T
‫متاسفانه این اینترفیس را پیاده سازی نکرده است.

20
00:01:41,848 --> 00:01:47,545
‫البته مایکروسافت این اینترفیس
‫را پیاده سازی کرده است اما
‫تنها پس از دریافت مثال‌های مترو
‫قابل دسترسی خواهد بود.

21
00:01:48,024 --> 00:01:53,861
‫مثال data binding آن کلاسی
‫را جهت پیاده سازی این اینترفیس
‫به همراه دارد.

22
00:01:54,659 --> 00:01:59,687
‫و نیاز خواهید داشت تا سورس آن را
‫در برنامه خود کپی کنید؛ به این ترتیب
‫data binding قادر خواهد بود تا تغییرات
‫در لیست‌ها را ردیابی کند.

23
00:02:00,905 --> 00:02:02,262
‫هرچند این مورد را به عنوان
‫یک چالش باقی گذاشته اند

24
00:02:02,800 --> 00:02:08,847
‫به علاوه باید دقت داشت که این مثال
‫از نوع جنریکی است که

25
00:02:08,917 --> 00:02:10,722
‫تنها اشیاء را به عنوان آرگومان می‌پذیرد.

26
00:02:11,481 --> 00:02:15,741
‫و امکان استفاده از نوع‌های سفارشی را

27
00:02:15,951 --> 00:02:16,699
‫ندارد.

28
00:02:17,896 --> 00:02:23,324
‫از این جهت که در WinRT ،
‫تصمیم گرفته شده است که آرگومان
‫جنریک معرفی شده به سیستم
‫ردیابی رخدادها، نمایان و عمومی باشد.

29
00:02:24,162 --> 00:02:29,729
‫و البته به نظر می‌رسد که این مورد
‫نسبت به INotifyCollectionChanged
‫دات نت یک بهبود باشد، زیرا در آنجا

30
00:02:30,029 --> 00:02:35,097
‫زیرا در آنجا تمام اشیاء قدیمی و جدید از نوع
‫System. Object تعریف شده بودند

31
00:02:35,167 --> 00:02:38,669
‫و برای انجام کاری مفید، باید آن‌ها
‫را نوع‌های مشخص، cast نمود

32
00:02:39,447 --> 00:02:42,770
‫اما حین کار با IObservableVector of T
‫این casting غیرضروری خواهد بود.

33
00:02:43,618 --> 00:02:51,949
‫اما متاسفانه این مورد سبب می‌شود
‫که در سناریوهایی که اینترفیس
‫مصرف کننده به نوع داده اهمیتی نمی‌دهد،
‫به خوبی کار نکند.

34
00:02:52,767 --> 00:02:58,913
‫برای مثال یک ListControl با
‫مجموعه ای از هر نوع اشیاء می‌تواند کار کند.
‫و در تئوری اهمیتی نخواهد داد که
‫T در حقیقت چیست؟

35
00:02:59,003 --> 00:03:00,569
‫اما مشکل اینجا است که

36
00:03:00,789 --> 00:03:03,014
‫نیاز خواهد داشت تا از منبع داده ای

37
00:03:03,283 --> 00:03:05,857
‫یک
‫IObservableVector of T را

38
00:03:05,987 --> 00:03:06,975
‫جهت مدیریت رخدادها، دریافت کند.

39
00:03:07,044 --> 00:03:10,586
‫و برای اینکه بتواند این درخواست
‫را ارائه دهد باید نوع T را نیز مشخص کند

40
00:03:11,185 --> 00:03:16,782
‫و در این حالت منبع داده ای چیزی
‫از T نمی‌داند که بخواهد آن را در اختیار
‫IObservableVector of T قرار دهد.

41
00:03:17,690 --> 00:03:19,127
‫و اگر کدهای شما

42
00:03:19,416 --> 00:03:20,903
‫از یک نوع سفارشی استفاده کند

43
00:03:21,531 --> 00:03:24,385
‫GridView یا ListView
‫نمی دانند که چگونه باید
‫آن را درخواست کنند

44
00:03:25,163 --> 00:03:28,745
‫بنابراین در عمل همیشه T از نوع
‫object خواهد بود.

45
00:03:30,391 --> 00:03:32,068
‫بنابراین در این سناریو خاص

46
00:03:32,207 --> 00:03:34,682
‫جنریک بودن این اینترفیس آنچنان
‫مفید نیست.

47
00:03:36,278 --> 00:03:39,650
‫البته مایکروسافت گفته است که قرار است
‫این مورد را پیش از ارائه نهایی بهتر کند

48
00:03:40,059 --> 00:03:47,562
‫بنابراین می‌توان امید داشت که همانند
‫WPF و Silverlight امکان استفاده از
ObservableCollection of T
‫نیز در اینجا مهیا گردد.

49
00:03:47,941 --> 00:03:51,523
‫اما فعلا زمانیکه IObservableVector of T
‫را پیاده سازی کنید

50
00:03:51,603 --> 00:03:53,411
‫برنامه کار خواهد کرد.

