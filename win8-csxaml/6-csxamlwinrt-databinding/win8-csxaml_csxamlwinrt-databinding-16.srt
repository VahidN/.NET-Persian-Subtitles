1
00:00:01,237 --> 00:00:03,142
‫دو کنترل لیستی جدید مترو

2
00:00:03,152 --> 00:00:06,664
‫ListView و GridView از
‫data virtualization پشتیبانی می‌کنند.

3
00:00:07,991 --> 00:00:13,838
‫این مورد فراتر است از مجازی سازی
‫المان‌های رابط کاربری موجود در
‫WPF و سیلورلایت

4
00:00:14,626 --> 00:00:26,569
‫در این دو فناوری، امکان ایجاد
‫به تاخیر افتاده المان‌های رابط کاربری
‫منابع داده ای را جهت کاهش مصرف حافظه
‫و بالابردن کارآیی عمومی برنامه با
‫ایجاد تنها آیتم هایی که قرار است

5
00:00:26,569 --> 00:00:28,485
‫هم اکنون نمایش داده شوند، دارند.

6
00:00:29,353 --> 00:00:30,819
‫WinRT نیز این مورد را پشتیبانی می‌کند.

7
00:00:31,119 --> 00:00:32,655
‫اما یک گام به جلو نیز در این زمینه برداشته است.

8
00:00:33,134 --> 00:00:36,926
‫در اینجا پشتیبانی مستقیم از مجازی
‫سازی خود منبع داده نیز وجود دارد.

9
00:00:37,953 --> 00:00:40,547
‫و دو شیوه مجازی سازی را پشتیبانی می‌کند.

10
00:00:41,056 --> 00:00:42,234
‫دسترسی اتفاقی

11
00:00:42,513 --> 00:00:43,461
‫و افزایشی (تدریجی)

12
00:00:44,878 --> 00:00:50,185
‫در حالت دسترسی اتفاقی فرض
‫بر این است که می‌دانیم چه تعداد
‫آیتم داده ای را در اختیار داریم

13
00:00:50,265 --> 00:00:52,690
‫و قصد نداریم آن‌ها را تا زمان نیاز،
‫بارگذاری نمائیم.

14
00:00:53,867 --> 00:01:04,273
‫ممکن است از این امکان برای نمایش
‫لیست لغزنده ای از هزاران آیتم استفاده کنید،
‫که نمایش اطلاعات هر کدام از آیتم‌ها
‫نیاز به دریافت اطلاعات از سرور باشد
‫و در این حالت فقط اطلاعاتی که نیاز هستند
‫دریافت خواهند شد.

15
00:01:05,730 --> 00:01:12,455
‫این نوع از مجازی سازی نیاز دارد تا
‫منبع داده ای مورد استفاده، اینترفیسی
‫را به نام IVirtualizingVector
‫پیاده سازی کند.

16
00:01:13,393 --> 00:01:19,539
‫برای پیاده سازی آن همچنین نیاز
‫به پیاده سازی اینترفیس IObservableVector
‫که پیشتر با آن آشنا شدیم نیز وجود دارد.

17
00:01:20,576 --> 00:01:23,510
‫تنها چیزی که IVirtualizingVector
‫اضافه می‌کند

18
00:01:23,669 --> 00:01:25,266
‫متدی است که

19
00:01:25,346 --> 00:01:26,323
‫IsPlaceholder نام دارد.

20
00:01:27,441 --> 00:01:30,404
‫زمانیکه منبع داده شما آیتمی
‫را از indexer خود بر می‌گرداند

21
00:01:30,723 --> 00:01:33,527
‫کنترل لیستی متد IsPlaceholder
‫را فراخوانی می‌کند

22
00:01:33,527 --> 00:01:37,678
‫تا دریابد که آیا اطلاعاتی کاملا
‫بارگذاری شده بازگشت داده شده است یا خیر

23
00:01:38,067 --> 00:01:39,164
‫و یا اینکه

24
00:01:39,314 --> 00:01:41,299
‫هنوز اطلاعات واقعی آماده نیست.

25
00:01:42,297 --> 00:01:43,824
‫اگر Placeholder را بازگشت دهید

26
00:01:44,263 --> 00:01:46,318
‫کنترل یک مستطیل خاکستری را

27
00:01:46,318 --> 00:01:47,445
‫در مکان المان، نمایش خواهد داد.

28
00:01:49,032 --> 00:01:50,848
‫زمانیکه اطلاعات واقعی را دریافت کردید

29
00:01:51,297 --> 00:01:55,836
‫باید رخداد VectorChanged فراخوانی گردد،
‫تا مشخص شود که تغییراتی در اطلاعات
‫دریافتی حاصل گردیده است.

30
00:01:56,804 --> 00:02:00,196
‫این مورد سبب می‌شود که کنترل،
‫از منبع داده ای آیتم مورد نظر را مجددا
‫درخواست کند.

31
00:02:00,975 --> 00:02:04,766
‫و مجددا IsPlaceholder را فراخوانی
‫می کند تا دریابد که اطلاعات
‫کامل شده است یا خیر.

32
00:02:05,694 --> 00:02:09,974
‫در این زمان احتمالا منبع داده مجازی
‫شما خواهد گفت، خیر. زیرا اکنون
‫اطلاعات دریافتی تکمیل و مهیا است.

33
00:02:09,974 --> 00:02:12,149
‫و در این حالت کنترل، آیتم را به شکل
‫متداول و معمولی نمایش خواهد داد.

34
00:02:13,825 --> 00:02:16,110
‫بهینه سازی اختیاری نیز در اینجا ممکن است.

35
00:02:16,579 --> 00:02:18,525
‫می توان اینترفیس دیگری را نیز پیاده سازی کرد

36
00:02:18,864 --> 00:02:20,620
‫به نام
IPreFetchingVector

37
00:02:21,149 --> 00:02:24,321
‫که دارای متدی است به نام
PreFetchAsync

38
00:02:25,299 --> 00:02:30,557
‫کنترل‌های ListView و GridView
‫حین احساس نیاز به اطلاعات، این متد را
‫فراخوانی خواهند کرد.

39
00:02:31,026 --> 00:02:33,321
‫بنابراین اگر کاربر شروع به لغزش
‫اطلاعات کنترل نماید

40
00:02:33,800 --> 00:02:37,791
‫می توان متد PreFetchAsync را
‫جهت آیتم‌های داده ای که مورد نیاز است
‫فراخوانی کرد.

41
00:02:38,898 --> 00:02:44,755
‫ایده این است که با رسیدن کاربر
‫به آیتمی مورد نظر، اطلاعات را
‫برای آنها پیشتر بارگذاری کرده باشید.

42
00:02:45,813 --> 00:02:52,138
‫به این ترتیب کاربر در این حالت تجربه
‫یکنواخت و دلپذیرتری را خواهد داشت،
‫زیرا در اکثر موارد کاربران، Placeholder
‫را حتی مشاهده هم نخواهند کرد

43
00:02:52,178 --> 00:02:57,326
‫زیرا سرعت اسکرول بسیار
‫بیشتر از سرعت دریافت داده خواهد بود.

44
00:03:00,330 --> 00:03:02,405
‫نوع دیگر اعمال مجازی شده

45
00:03:02,644 --> 00:03:04,311
‫بارگذاری تدریجی (افزایشی) می‌باشد.

46
00:03:05,468 --> 00:03:09,000
‫این حالت برای کنترل‌های لیستی
‫طراحی شده است که هم اکنون
‫بسیار محبوب و پرکاربرد می‌باشند

47
00:03:09,020 --> 00:03:11,454
‫برای مثال در برنامه‌های ‫شبکه‌های اجتماعی متفاوت.

48
00:03:11,963 --> 00:03:18,389
‫در این حالت ابتدا لیستی از آیتم‌ها
‫مثلا 30 یا 40 تا از آن‌ها ارائه می‌شود

49
00:03:18,917 --> 00:03:23,627
‫و سپس با لغزیدن به پایین لیست،
‫به مرور اطلاعات بیشتری دریافت می‌گردد.

50
00:03:24,385 --> 00:03:28,216
‫به این ترتیب می‌توان به لیست‌های
‫بالقوه نامحدودی رسید.

51
00:03:28,905 --> 00:03:31,459
‫برای مثال این مورد جهت نمایش timeline
‫فعالیت‌های اجتماعی مفید است.

52
00:03:31,658 --> 00:03:34,203
‫به نحوی که هر بار با لغزش به هر
‫زمان دلخواهی، اطلاعات مرتبط بارگذاری شوند.

53
00:03:35,809 --> 00:03:43,731
‫به نظرم این روش، دارای مشکلات
‫کاربری می‌باشد، زیرا با زیاد شدن
‫اطلاعات نمایش داده شده در لیست،
‫اندازه نوار لغزشی نیز تغییر می‌کند

54
00:03:44,370 --> 00:03:49,787
‫به این معنا که اگر برنامه در ابتدا
‫با لغزش اسکرول بار توسط ماوس
‫مقدار اندکی از اطلاعات را دریافت کند

55
00:03:50,126 --> 00:03:52,521
‫به رفتار غیرقابل پیش بینی خواهیم رسید

56
00:03:53,609 --> 00:03:58,328
‫هر چند این مورد با وسایل لمسی
‫آنچنان مشکلی نیست. زیرا نحوه اسکرول
‫به کمک کشیدن و رها کردن اسکرول بار نیست.

57
00:04:00,154 --> 00:04:02,259
‫برای پشتیبانی از این نوع مجازی سازی

58
00:04:02,578 --> 00:04:07,297
‫منبع داده ای شما باید اینترفیس
IIncrementalLoadingVector
‫را پیاده سازی کند.

59
00:04:08,006 --> 00:04:16,287
‫در این حالت امکان تعیین batch size
‫ (تعداد اطلاعاتی که در یکبار رفت و برگشت
‫باید دریافت شوند) و همچنین
‫با نزدیک شدن کاربر به پایان لیست، میزان
‫دریافت اطلاعات را نیز می‌توان تنظیم کرد.

60
00:04:16,287 --> 00:04:19,869
‫همچنین متدی برای دریافت صریح
‫میزان داده بیشتری نیز وجود دارد

61
00:04:20,268 --> 00:04:22,094
‫به نام
LoadMoreItemsAsync

62
00:04:22,772 --> 00:04:30,964
‫و اگر می‌خواهید بر این امر کنترل
‫کاملی داشته باشید، امکان غیرفعال کردن
‫دریافت خودکار اطلاعات نیز وجود دارد. در این حالت
‫تنها زمانی اطلاعات بیشتری دریافت خواهد شد
‫که LoadMoreItemsAsync
‫فراخوانی گردد.

63
00:04:33,508 --> 00:04:41,250
‫این دو کنترل لیستی جدید به دنبال
‫دو اینترفیس یاد شده بر روی تمام
‫منابع داده ای خواهند گشت،
‫و به صورت خودکار قابلیت‌های مرتبط را

64
00:04:41,420 --> 00:04:42,857
‫در صورت وجود و پیاده سازی این اینترفیس‌ها
‫فعال خواهند کرد.

65
00:04:43,675 --> 00:04:48,005
‫هرچند باید دقت داشت که امکان
‫بکارگیری هر دو حالت دسترسی اتفاقی
‫و تدریجی با هم میسر نیست.

66
00:04:48,015 --> 00:04:49,611
‫و حالت انتخاب این یکی و یا تنها آن یکی
‫مطرح است.

67
00:04:50,270 --> 00:04:55,767
‫و اگر هر به هر علتی، هر دو اینترفیس
‫را بر روی یک منبع داده ای پیاده سازی کردید

68
00:04:56,047 --> 00:05:02,402
‫با تنظیم خاصیت مرجح بارگذاری تدریجی
‫اطلاعات به true یا false
‫می توان یکی را بر دیگری برگزید.

69
00:05:03,091 --> 00:05:05,765
‫و در کل باید از وارد شدن به این وضعیت
‫پرهیز کنید.

70
00:05:06,064 --> 00:05:11,244
‫تنها منبع داده ای را جهت نوعی مناسب
‫با روشی مشخص ارائه دهید.

