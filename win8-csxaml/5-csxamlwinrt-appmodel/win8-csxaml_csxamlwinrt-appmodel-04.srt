1
00:00:00,310 --> 00:00:04,129
‫در جلسه قبل تعدادی سطر کد را
‫جهت مدیریت رخداد تعلیق برنامه به شما
‫نمایش دادم

2
00:00:04,164 --> 00:00:07,252
‫اما بدنهٔ متدهای بکار گرفته شده
‫را بررسی نکردیم.

3
00:00:07,374 --> 00:00:09,939
‫شامل ذخیره سازی اطلاعات کاربر و همچنین
‫حالت سشن

4
00:00:10,289 --> 00:00:13,007
‫اکنون اجازه دهید تا این موارد را
‫با جزئیات بیشتری بررسی کنیم.

5
00:00:13,368 --> 00:00:17,985
‫روشی را که اینجا ملاحظه خواهید کرد،
‫تنها روش حل این مسایل نیست

6
00:00:18,396 --> 00:00:20,817
‫اما یک راه حل کاربردی و مفید
‫را توضیح خواهد داد

7
00:00:21,109 --> 00:00:24,201
‫کلاسی را تهیه کرده ام به نام
ModelRepository

8
00:00:24,542 --> 00:00:28,609
‫کار آن ذخیره سازی اطلاعات مدل برنامه
‫است

9
00:00:28,676 --> 00:00:30,692
‫و سپس بازیابی آن پس از شروع
‫مجدد برنامه

10
00:00:30,902 --> 00:00:35,729
‫ابتدا با کدهای ذخیره سازی اطلاعات بر
‫روی سخت دیسک شروع می‌کنم

11
00:00:35,767 --> 00:00:39,040
‫که مرتبط با متد
SaveFavouritesToAsync
‫می باشد

12
00:00:39,364 --> 00:00:41,760
‫همانطور که ملاحظه می‌کنید این متد
‫خالی است و باید تکمیل شود

13
00:00:42,107 --> 00:00:49,889
‫ابتدا نیاز است تا شیء اشاره کننده
‫به پوشه ذخیره سازی اطلاعات برنامه را
‫ایجاد کنیم.

14
00:00:50,031 --> 00:00:55,234
‫کلاس StorageFolder مخصوص WinRT
‫بیانگر پوشه ذخیره سازی اطلاعات برنامه است.

15
00:00:55,638 --> 00:01:01,129
‫شیء ApplicationData امکان دسترسی به
‫انواع و اقسام پوشه‌ها را میسر ‫می سازد.

16
00:01:01,286 --> 00:01:06,373
‫و LocalFolder بیانگر پوشه محلی مرتبط با
‫پروفایل کاربر جاری سیستم است.

17
00:01:06,446 --> 00:01:13,585
‫هرچیزی که در اینجا ذخیره شود در
‫پوشه Roaming کاربر قرار نمی‌گیرد و
‫منحصر است به سیستم جاری

18
00:01:13,640 --> 00:01:21,253
‫امکان استفاده از Roaming Folder نیز
‫وجود دارد، اما اگر نیاز به هماهنگ
‫سازی اطلاعات بین تمام سیستم هایی
‫که کاربر از آن استفاده می‌کند
‫وجود دارد

19
00:01:21,370 --> 00:01:23,876
‫Roaming Profile کمکی نخواهد کرد.

20
00:01:23,991 --> 00:01:26,685
‫زیرا این پروفایل تنها در حالت‌های ‫logon
‫و log off به روز رسانی ‫می شود.

21
00:01:26,998 --> 00:01:30,124
‫اگر کاربر هم از دسکتاپ و هم
‫از تبلت استفاده می‌کند

22
00:01:30,472 --> 00:01:32,018
‫کاربر به هر دو در یک زمان
‫وارد خواهد شد

23
00:01:32,229 --> 00:01:35,756
‫در این حالت نیاز به امکانات هماهنگ
‫سازی بهتری نسبت به Roaming Profile
‫خواهد بود.

24
00:01:35,958 --> 00:01:40,274
‫هماهنگ سازی بین چند سیستم فراتر از
‫بحث جاری است.

25
00:01:40,336 --> 00:01:41,823
‫به همین جهت این اطلاعات را فعلا
‫محلی ثبت خواهیم کرد.

26
00:01:42,023 --> 00:01:47,433
‫کار بعدی ایجاد فایلی است که می‌‫خواهیم
‫اطلاعات را در آن ذخیره کنیم.

27
00:01:47,833 --> 00:01:52,042
‫در WinRT فایل‌ها توسط کلاس
‫StorageFile بیان می‌شوند.

28
00:01:52,405 --> 00:02:01,510
‫توسط شیء floder ایجاد شده و متد
‫غیر همزمان CreateFileAsync آن همانند
‫تمام متدهای اینچنینی WinRT
‫نسبت به ایجاد یک فایل جدید اقدام
‫خواهیم کرد.

29
00:02:01,630 --> 00:02:07,175
‫قصد بازنویسی فایل موجود را ندارم، زیرا
‫ممکن است با شکست مواجه شود.

30
00:02:07,226 --> 00:02:11,406
‫نباید یک فایل غیرکامل را با آخرین
‫فایل مفید موجود بازنویسی کرد.

31
00:02:11,432 --> 00:02:16,354
‫بنابراین از یک ثابت رشته ای به
‫نام FavouritesListNewFileName
‫استفاده خواهم کرد

32
00:02:16,451 --> 00:02:18,558
‫که در ابتدای این کلاس تعریف شده ‫است.

33
00:02:18,686 --> 00:02:20,845
‫و همانطور که ملاحظه می‌کنید تعدادی
‫نام فایل دیگر نیز در اینجا تعریف ‫شده اند.

34
00:02:21,023 --> 00:02:27,565
‫یک فایل برای ذخیره سازی اطلاعات در
‫حال تهیه و نوشتن و فایلی دیگر
‫برای نوشتن اطلاعات تکمیل شده

35
00:02:27,838 --> 00:02:31,920
‫در متد CreateFileAsync مشخص خواهم کرد که
‫قصد ندارم هیچ فایل موجودی را بازنویسی ‫کنم.

36
00:02:32,105 --> 00:02:38,077
‫اگر فایلی به این نام وجود داشت
‫به این معنا است که یک فایل
‫نیمه کاره از قبل و حاصل یک تلاش
‫شکست خورده می‌باشد.

37
00:02:38,160 --> 00:02:39,372
‫بنابراین بوسیله ثابت
CreateCollisionOption. ReplaceExisting
‫آن فایل ناقص را بازنویسی خواهیم کرد.

38
00:02:39,450 --> 00:02:44,197
‫هرچند StorageFolder بیانگر یک فایل می‌باشد

39
00:02:44,417 --> 00:02:48,628
‫سرویس مستقیمی را جهت کار با فایل
‫ارائه نمی‌دهد.

40
00:02:48,868 --> 00:02:51,889
‫تنها اطلاعاتی را جهت آن مهیا می‌‫سازد.

41
00:02:52,098 --> 00:02:53,980
‫اگر قصد داشته باشیم که اطلاعاتی را
‫در فایل بنویسیم.

42
00:02:54,323 --> 00:02:57,090
‫نیاز خواهیم داشت تا از Stream API
‫مرتبط با WinRT استفاده کنیم.

43
00:02:57,410 --> 00:03:00,498
‫با IRandomAccessStream شروع می‌کنیم

44
00:03:00,763 --> 00:03:03,889
‫که حاصل file. OpenAync می‌باشد

45
00:03:04,207 --> 00:03:06,190
‫و بیانگر نوع دسترسی است که نیاز ‫داریم.

46
00:03:06,502 --> 00:03:09,955
‫در اینجا حالت WriteOnly وجود ندارد، بنابراین

47
00:03:10,231 --> 00:03:11,447
‫از حالت FileAccessMode. ReadWrite استفاده
‫خواهم کرد.

48
00:03:11,836 --> 00:03:17,708
‫با IRandomAccessStream دریافتی نیز نمی‌توان
‫به صورت مستقیم کار خاصی را انجام ‫داد.

49
00:03:17,962 --> 00:03:21,111
‫ras تنها یک factory جهت استریم‌های
‫ورودی و خروجی است.

50
00:03:21,508 --> 00:03:26,786
‫بنابراین به کمک متد
‫GetOutputStream آن، استریم خروجی را
‫از آفست صفر دریافت خواهیم کرد.

51
00:03:27,145 --> 00:03:29,460
‫بنابراین تا اینجا به استریم خروجی
‫دسترسی پیدا کردیم.

52
00:03:29,483 --> 00:03:31,727
‫اکنون نیاز خواهیم داشت تا چیزی را
‫در آن ثبت کنیم.

53
00:03:32,052 --> 00:03:34,721
‫متد من آرایه ای از اشیاء را
‫دریافت می‌کند.

54
00:03:34,836 --> 00:03:39,980
‫کار این قسمت از برنامه ذخیره سازی
‫لیست علاقمندی‌های کاربر است.

55
00:03:40,107 --> 00:03:44,767
‫اگر به تعریف کلاس FavouriteThing
‫مراجعه کنم، با کلاس ساده ای روبرو
‫خواهیم شد که حاوی یک خاصیت
‫رشته ای به نام توضیحات است.

56
00:03:45,117 --> 00:03:48,874
‫به جهت سادگی آن، این کلاس
‫را مستقیما Serialize می‌کنم.

57
00:03:49,251 --> 00:03:52,966
‫در یک برنامه واقعی ممکن است مدل
‫شما پیچیده‌تر باشد

58
00:03:53,192 --> 00:03:56,722
‫و نیاز داشته باشید تا لایه دیگری
‫را جهت ذخیره سازی اطلاعات ایجاد کنید.

59
00:03:57,084 --> 00:03:58,344
‫اما در این مثال اندکی زیاده روی ‫است.

60
00:03:58,637 --> 00:04:06,259
‫امکانات Serialization دات نت مترو،
‫تمام گزینه‌های مرتبط مهیا در دات نت
‫فریم ورک کامل را به همراه ندارد

61
00:04:06,622 --> 00:04:10,714
‫اما کلاس DataContractSerializer
‫در اینجا حداقل به خوبی کار می‌‫کند.

62
00:04:10,960 --> 00:04:17,175
‫DataContractSerializer را با
‫وهله ای از آرایه FavouriteThing
‫مقدار دهی می‌کنم.

63
00:04:17,248 --> 00:04:22,364
‫اکنون به کمک آن می‌توان
‫مدل برنامه را در فایل ذخیره کرد.

64
00:04:22,459 --> 00:04:24,430
‫هرچند یک نکته را باید در اینجا
‫درنظر داشت.

65
00:04:24,531 --> 00:04:28,522
‫DataContractSerializer از دات نت
‫فریم ورک گرفته شده است

66
00:04:28,575 --> 00:04:32,464
‫بنابراین از استریم دات نتی مشتق شده
‫از فضای نام System. IO بهره خواهد برد

67
00:04:32,517 --> 00:04:39,553
‫که از نوع استریم‌های WinRT خروجی
‫تعریف شده در اینجا نیست.

68
00:04:39,861 --> 00:04:42,056
‫بنابراین به نوعی محصور کننده در اینجا
‫نیاز خواهد بود.

69
00:04:42,361 --> 00:04:48,948
‫بعضی از استریم‌های دات نت به
‫صورت خودکار به نمونه‌های WinRT
‫نگاشت خواهند شد

70
00:04:49,351 --> 00:04:53,848
‫اما استریم‌های دات نت و WinRT
‫با هم تفاوت دارند.

71
00:04:54,196 --> 00:04:56,892
‫و مایکروسافت تصمیم گرفته است
‫که این‌ها را به صورت خودکار
‫نگاشت نکند.

72
00:04:57,314 --> 00:05:02,471
‫بنابراین وظیفهٔ ما خواهد بود تا
‫اینکار را دستی انجام دهیم.

73
00:05:02,750 --> 00:05:04,733
‫اما انجام اینکار بسیار ساده است.

74
00:05:04,933 --> 00:05:12,365
‫برای حل این مشکل، متد الحاقی
‫در فضای نام System. IO جهت
‫تبدیل استریم‌های دات نت به
‫نمونه WinRT وجود دارد

75
00:05:12,745 --> 00:05:17,336
‫بنابراین تنها کافی است متد الحاقی
AsStream
‫بر روی این استریم خروجی فراخوانی گردد.

76
00:05:18,156 --> 00:05:28,373
‫این متد الحاقی توسط اسمبلی
system. runtime. windowsruntime
‫به فضای نام System. IO
‫اضافه شده است.

77
00:05:29,800 --> 00:05:42,651
‫این استریم را به کمک کلمه کلیدی using
‫محصور خواهم کرد، زیرا به این ترتیب
‫مطمئن خواهم شد که استریم تعریف شده
‫بلافاصله پس از پایان متد، توسط GC
‫معدوم شده و فایل مورد استفاده را باز
‫باقی نخواهد گذاشت.

78
00:05:43,639 --> 00:05:49,814
‫و اکنون تمام کاری که باید انجام شود
‫این است که به serializer بگویم تا
‫آرایه مورد نظر را در استریم بنویسد.

79
00:05:51,620 --> 00:05:54,085
‫نکتهٔ کوچکی در این مورد وجود دارد

80
00:05:54,324 --> 00:06:02,905
‫تمام اعمال دسترسی به فایل سیستم
‫در اینجا از کلمه کلیدی await
‫استفاده کرده اند، منهای متد
‫WriteObject آخری

81
00:06:03,703 --> 00:06:10,597
‫به طور قطع این متد هم کار FileIO را
‫انجام می‌دهد و اگر قرار باشد تعداد زیادی
‫شیء را توسط آن در فایل سیستم درج کنیم
‫مدت زمان زیادی طول خواهد کشید.

82
00:06:11,775 --> 00:06:28,975
‫هر چند WinRT تنها اعمال غیرهمزمان
‫FileIO را پشتیبانی می‌کند؛ محصور
‫کننده دات نتی هر دوی دسترسی‌های ‫
‫همزمان و غیرهمزمان را ارائه می‌دهد. 
‫زیرا کلاس پایه Stream بر این مبنا تهیه شده
‫و تعدادی از کلاس‌ها مانند DataContractSerializer
‫تنها بر اساس نمونه همزمان آن کار می‌کنند.

83
00:06:30,093 --> 00:06:42,086
‫اگر در اینجا یکی از متدهای همزمان مانند
‫WriteObject را فراخوانی کنید؛ محصور کننده
‫ارائه شده نسخهٔ غیرهمزمان WinRT را
‫به صورت خودکار فراخوانی کرده و
‫سپس ترد را تا پایان عملیات قفل می‌کند.

84
00:06:42,944 --> 00:06:49,130
‫بنابراین هرچند کل این متد async معرفی شده
‫اجرای آن در ترد اصلی رابط کاربری برنامه
‫صحیح نیست.

85
00:06:49,798 --> 00:06:57,960
‫اگر کمی به بالاتر مراجعه کنیم، مشاهده
‫خواهید کرد که به کمک کلاس Task
‫این متد ذخیره سازی را در استخر تردهای
‫مهیا اجرا خواهیم کرد.

86
00:06:59,287 --> 00:07:01,791
‫البته مجبور هستیم اینکار را به هرحال
‫انجام دهیم

87
00:07:02,509 --> 00:07:11,269
‫حتی در حالتی که DataContractSerializer
‫اشیاء ما را به کمک متد غیرهمزمان صحیحی
‫در پشت صحنه اجرا می‌کند؛ و البته این مورد
‫به مشکلات نگارش آزمایشی فعلی ویندوز 8
‫بر می‌گردد.

88
00:07:11,838 --> 00:07:19,910
‫در این نگارش آزمایشی، انجام هر نوع اعمال IO
‫در ترد اصلی برنامه سبب بروز deadlock
‫خواهد شد؛ حتی اگر از اعمال غیرهمزمان
‫صحیحی نیز استفاده شده باشد.

89
00:07:20,319 --> 00:07:22,155
‫بنابراین فعلا مجبور هستیم که از استخر تردها
‫کمک بگیریم.

90
00:07:23,951 --> 00:07:31,543
‫آخرین مطلب این است که هر چند موفق شدیم
‫یک فایل کامل را بنویسیم، نیاز خواهیم داشت
‫تا نام آن را تغییر دهیم تا به فایل جاری تبدیل شود.

91
00:07:32,790 --> 00:07:37,939
‫در WinRT اینکار به کمک متد
‫file. RenameAsync انجام می‌شود.

92
00:07:38,917 --> 00:07:49,991
‫این عمل نیز غیرهمزمان است؛ زیرا قرار است
‫کار FileIO را انجام دهد. برای این منظور
‫پس از فراخوانی متد RenameAsync ،
‫به آن خواهیم گفت که در صورت وجود فایل
‫مشابهی، باید آن را بازنویسی کند.

93
00:07:50,760 --> 00:07:54,681
‫اکنون بازنویسی فایل قبلی عملی امن
‫به شمار می‌رود، زیرا در این لحظه
‫کار نوشتن فایل تمام شده است.

94
00:07:56,147 --> 00:08:01,216
‫این تمام کاری است که باید انجام شود. 
‫اما چگونه و کجا باید این متدهای تهیه شده
‫را فراخوانی نمائیم.

95
00:08:01,216 --> 00:08:05,556
‫این مخزن، مجموعه اشیاء مورد علاقه را
‫به عنوان یک خاصیت معرفی کرده است.

96
00:08:06,294 --> 00:08:09,537
‫همچنین این کلاس مخزن حاوی متدی است
‫جهت افزودن علاقمندی‌های جدید.

97
00:08:10,195 --> 00:08:15,214
‫این متد، مدل تشکیل شده در حافظه ما
‫را به روز رسانی کرده و سپس با فراخوانی
‫متدی کمکی، حالت سشن را ذخیره خواهد نمود.

98
00:08:16,222 --> 00:08:27,566
‫در این متد کمکی، ابتدا بررسی می‌شود که
‫آیا عملیات ذخیره سازی در جریان است؟
‫اگر خیر، همان زمان کار ذخیره سازی را شروع کرده
‫و سپس کل عملیات را به صورت در حال انجام
‫علامت گذاری خواهد کرد.

99
00:08:27,945 --> 00:08:30,340
‫اما اگر هم اکنون کار مشابهی در حال
‫انجام باشد.

100
00:08:30,390 --> 00:08:42,312
‫Task جدیدی را ایجاد کرده و آن را در صف
‫قرار می‌دهد به نحوی که تنها پس از پایان
‫کار جاری، این عملیات انجام خواهد شد. 
‫سپس خروجی آن این Task را پس از پایان آن
‫دریافت خواهیم کرد.

101
00:08:43,590 --> 00:08:50,843
‫بنابراین این متد دو کار را انجام می‌دهد. 
‫ابتدا عدم تداخل بین عمل درخواستی
‫و عملی در جریان را بررسی می‌کند.

102
00:08:51,262 --> 00:09:03,235
‫این اعمال یکی پس از دیگری اجرا خواهند شد. 
‫این مورد بسیار مهم است، زیرا بکارگیری
‫واژه‌های کلیدی await و async با بالا
‫رفتن حجم کد، ممکن است ما را به
‫اشتباه بیندازند.

103
00:09:04,911 --> 00:09:12,035
‫دوم اینکه مشخص می‌شود آیا
‫کاری در حال انجام است که باید به
‫پایان برسد، پیش از اینکه حالت سشن
‫را بخواهیم ذخیره کنیم.

104
00:09:12,624 --> 00:09:29,984
‫زمانیکه برنامه در حال تعلیق است،
‫ابتدا باید اطمینان حاصل کرد که اطلاعات
‫کاربر به نحو امنی ذخیره شده اند و به این
‫ترتیب تعدادی عمل غیرهمزمان با اهمیت کمتر
‫در صف قرار گرفته و اعمال مهم‌تر ذخیره سازی
‫ابتدا انجام خواهند شد.

105
00:09:31,161 --> 00:09:41,129
‫بنابراین در این متد ابتدا بررسی می‌شود
‫که آیا اعمالی برای ذخیره سازی وجود دارند
‫و اگر بله، تا پایان آن‌ها صبر خواهد شد.

106
00:09:41,408 --> 00:09:43,773
‫و اگر به خاطر داشته باشید،
‫این همان متدی است که در حین تعلیق
‫فراخوانی کردیم.

107
00:09:45,020 --> 00:09:59,018
‫اگر به فایل app. xaml. cs برگردیم،
‫این فراخوانی را می‌توانید ملاحظه کنید. 
‫که در حقیقت سبب ذخیره سازی هیچ چیزی
‫نمی شود. بلکه به این معنا است که
‫اگر پیشتر یک سری عملیات ذخیره سازی
‫در جریان بود، باید صبر کرد.

108
00:10:00,136 --> 00:10:04,166
‫بنابراین به این ترتیب مشاهده کردیم که
‫عملیات ذخیره سازی اطلاعات چگونه
‫پردازش و به پایان خواهد رسید.

109
00:10:04,745 --> 00:10:07,359
‫اما هنوز کدی که ذخیره سازی را آغاز
‫می کند مشاهده نکرده ایم.

110
00:10:08,127 --> 00:10:11,270
‫ذخیره سازی اطلاعات در حین
‫اجرای معمولی برنامه رخ می‌دهد.

111
00:10:12,268 --> 00:10:20,649
‫متدی را ملاحظه کردید که کارش افزودن
‫اشیاء علاقمندی جدید بود به همراه ذخیره
‫سازی آن. بنابراین هر زمان که کاربر آیتم
‫جدیدی را اضافه می‌کند، ذخیره سازی
‫آن را بلافاصله شروع خواهیم کرد.

112
00:10:21,667 --> 00:10:27,613
‫به همین منظور اجازه دهید تا
‫روال رخدادگردان افزودن اطلاعات
‫را در صفحه اصلی برنامه مشاهده کنیم.

113
00:10:28,282 --> 00:10:31,454
‫این روال یک متد کمکی کلیک موجود
‫در view model برنامه را فراخوانی می‌کند.

114
00:10:32,043 --> 00:10:32,861
‫اجازه دهید نگاهی به آن بیندازیم.

115
00:10:34,228 --> 00:10:38,309
‫همانطور که ملاحظه می‌کنید کار این
‫متد تنها افزودن یک آیتم به کمک
‫کلاس مخزنی است که پیشتر تعریف کردیم.

116
00:10:39,067 --> 00:10:44,934
‫این متد ترد جاری را بلاک نکرده و تنها
‫سبب اجرا یک عمل غیرهمزمان خواهد شد
‫که عاقبت تکمیل می‌گردد.

117
00:10:45,482 --> 00:10:54,103
‫به این ترتیب می‌توان اطمینان حاصل کرد
‫که تمام اعمال ذخیره سازی ما پیش از
‫آغاز تعلیق برنامه تمام شده اند.

118
00:10:55,330 --> 00:11:03,482
‫البته هیچکدام از این اعمال آنچنان زمانبر نیستند. 
‫و احتمال اینکه عملی در زمان شروع تعلیق
‫به پایان نرسیده باشد، بسیار نادر است.

119
00:11:05,407 --> 00:11:05,896
‫اکنون

120
00:11:06,575 --> 00:11:13,648
‫یک نفس عمیق بکشید، زیرا تا اینجا نصف
‫داستان تعریف شده است! 
‫هنوز نحوهٔ بازیابی حالات را بررسی نکرده ایم.

121
00:11:14,257 --> 00:11:16,143
‫البته این مورد بسیار ساده‌تر است.

122
00:11:16,921 --> 00:11:32,376
‫کلاس مخزن من شامل یک متد غیرهمزمان
‫بارگذاری نیز می‌باشد. این متد نیز
‫از استخر تردها برای انجام کارهای خودش
‫استفاده می‌کند تا مطمئن شود که کار
‫IO تداخلی در ترد اصلی برنامه ایجاد نمی‌کند. 
‫به علاوه یک سری کد هم در اینجا وجود دارند
‫بر این مبنا که ما هنوز چیزی را ذخیره نکرده ایم.

123
00:11:32,785 --> 00:11:36,776
‫اولین باری که برنامه اجرا می‌شود،
‫اطلاعاتی بر روی سخت دیسک
‫وجود نخواهد داشت.

124
00:11:37,474 --> 00:11:51,772
‫و اگر وجود داشته باشد، کدی را شبیه
‫به کدهای ذخیره سازی حالت اجرا می‌کند. 
‫در ابتدا یک Stream ورودی مخصوص WinRT
‫دریافت شده و در یک استریم دات نتی محصور شده و
‫به کلاس‌های DataContractSerializer
‫دات نتی ارسال می‌شود.

125
00:11:53,408 --> 00:11:57,918
‫اکنون سؤال اینجا است که این متد
‫چه زمانی و در کجا باید برای بارگذاری مدل
‫فراخوانی شود.

126
00:11:58,746 --> 00:12:14,201
‫ما قصد داریم این کد را در زمان شروع
‫پروسه برنامه اجرا کنیم. اگر ابتدا
‫برنامه تعلیق و سپس بازیابی شده، نیازی
‫به این بارگذاری مجدد نیست. زیرا
‫در این حالت نباید انتظار داشته باشیم
‫که یک فایل محلی مخصوص این برنامه
‫تغییری کرده باشد.

127
00:12:15,278 --> 00:12:18,132
‫برای انجام اینکار از سازنده کلاس App
‫استفاده خواهیم کرد.

128
00:12:19,160 --> 00:12:26,892
‫این کار می‌کند، البته باید به یک
‫نکته نیز توجه داشت. سازنده کلاس App
‫در ترد اصلی رابط کاربری برنامه اجرا نمی‌شود.

129
00:12:27,491 --> 00:12:34,694
‫هرچند این متد در ترد اصلی برنامه اجرا می‌شود
‫اما به این معنا است که WinRT برای
‫اعمال UI یک ترد جداگانه را ایجاد می‌کند.

130
00:12:34,734 --> 00:12:39,374
‫و اگر از این ترد برای انجام اعمال
‫غیرهمزمان WinRT استفاده کنید،
‫به مشکل برخواهید خورد.

131
00:12:40,152 --> 00:12:50,229
‫البته ما در اینجا همه چیز را توسط
‫استخر تردها اجرا می‌کنیم اما باید
‫به باگ فعلی موجود در نگارش
‫آزمایشی ویندوز 8 که پیشتر
‫به آن اشاره شد، دقت داشت.

132
00:12:50,468 --> 00:12:53,691
‫به این ترتیب می‌توان از مشکلات
‫استفاده از استخر تردها فارغ شد

133
00:12:53,811 --> 00:13:01,972
‫زیرا با وهله سازی کلاس مخزن در
‫ترد اصلی رابط کاربر برنامه،
‫مشکلات به روز رسانی آن با توجه به
‫وجود synchronisation context
‫به حداقل خواهد رسید.

134
00:13:03,219 --> 00:13:17,756
‫بنابراین کلاس مخزن خود را در روال
‫رخدادگران آغازین برنامه شروع کرده
‫و به این ترتیب در ترد رابط کاربر برنامه
‫اجرا خواهد شد و همچنین بررسی
‫خواهم کرد که این بارگذاری تنها
‫یکبار رخ می‌دهد. زیرا OnLaunched
‫یک پروسس ممکن است تحت شرایطی
‫چندین بار فراخونی شود.

135
00:13:18,405 --> 00:13:19,782
‫و این تمام مبحث است.

136
00:13:21,648 --> 00:13:39,627
‫در اینجا کار مدیریت حالت سشن را
‫انجام ندادیم و کار کلی آن مشابه است. 
‫باید اطلاعات مرتبط آن از طریق Serialization
‫به دیسک سخت منتقل شود. 
‫تفاوت اصلی هم در اینجا است که در این
‫حالت خواص کنترل‌ها را ذخیره و بازیابی
‫خواهیم کرد؛ اما اساسا تفاوت آنچنانی
‫با مباحث عنوان شده ندارد.

