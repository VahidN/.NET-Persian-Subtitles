1
00:00:00,310 --> 00:00:07,059
‫برنامه شما از رویدادهای اجرا، تعلیق و
‫اجرای مجدد به کمک کلاس App
‫مطلع خواهد گردید.

2
00:00:07,059 --> 00:00:15,548
‫تمام انواع پروژه‌های مترو در ویژوال
‫استودیو، از کلاس App مشتق شده از
‫کلاس برنامه در WinRT تشکیل می‌شوند.

3
00:00:15,715 --> 00:00:19,776
‫و در اینجا امکان تعریف روال‌های
‫رویدادگردان مختلف مرتبط با طول عمر
‫برنامه ‫جاری وجود دارد.

4
00:00:20,001 --> 00:00:24,910
‫برای مثال می‌توان یک روال رویدادگردان
‫تعلیق برنامه را در اینجا تعریف کرد.

5
00:00:24,980 --> 00:00:27,027
‫این رخداد، یک اخطار 5 ثانیه ای ‫است.

6
00:00:27,234 --> 00:00:30,103
‫بنابراین 2 کار مهم را باید در
‫این روال رویدادگران انجام داد.

7
00:00:30,149 --> 00:00:35,778
‫ابتدا باید مطمئن شویم که اطلاعات کاربر
‫در محل ذخیره سازی اطلاعات، درج شده ‫است.

8
00:00:35,981 --> 00:00:42,442
‫کلاس ModelRepository را که در اینجا
‫ملاحظه می‌کنید، یک کلاس WinRT نیست
‫و چیزی است که من به این برنامه
‫اضافه کرده ام.

9
00:00:42,442 --> 00:00:46,337
‫به جزئیات آن در ادامه برنامه خواهیم
‫پرداخت.

10
00:00:46,749 --> 00:00:48,793
‫بنابراین کدهای ‫داخل این متد را فعلا
‫نمایش نمی‌دهم.

11
00:00:49,167 --> 00:00:53,793
‫فعلا هدف نحوهٔ مشخص سازی ترتیب
‫صحیح انجام امور در این متد است.

12
00:00:54,185 --> 00:01:01,251
‫اولین کار، ذخیره سازی مطمئن تمام اطلاعاتی
‫است که برنامه باید به خاطر بسپارد.

13
00:01:01,570 --> 00:01:07,314
‫کار دومی که در این متد باید
‫انجام شود این است که تمام اطلاعات
‫موقتی حالات اشیاء رابط کاربری نیز باید
‫ذخیره گردند.

14
00:01:07,433 --> 00:01:11,865
‫برای مثال فرض کنید که برنامه شما
‫حاوی دو View مختلف است.

15
00:01:11,892 --> 00:01:14,407
‫زمانیکه در ابتدا اجرا می‌شود ممکن
‫است لیستی از آیتم‌ها را نمایش ‫دهد.

16
00:01:14,767 --> 00:01:19,166
‫و سپس کاربر ممکن است با کلیک بر روی
‫یکی از آیتم‌ها به نمایش جزئیات
‫آن مراجعه نماید.

17
00:01:19,257 --> 00:01:25,352
‫اگر حالت جاری برنامه شما نمایش
‫جزئیات ‫آیتمی است پیش از تعلیق

18
00:01:25,352 --> 00:01:28,593
‫باید همان View و همان آیتم را
‫پس از بازگشت از تعلیق و اجرای
‫مجدد، به کاربر نمایش داد.

19
00:01:28,836 --> 00:01:31,589
‫یا اگر برنامه شما در حال نمایش
‫لیست اصلی است

20
00:01:31,691 --> 00:01:34,904
‫و کاربر به مکان خاصی در آن
‫لیست اسکرول کرده است

21
00:01:35,298 --> 00:01:39,711
‫بدیهی است زمانیکه کاربر مجددا به
‫برنامه مراجعه می‌کند، باید همان مکان
‫را مشاهده نماید.

22
00:01:39,890 --> 00:01:46,458
‫اگر تغییر حالات صرفا تعلیق و بازیابی
‫از آن باشد، این بازیابی خودکار خواهد
‫بود؛ زیرا سیستم حالات برنامه را در
‫حافظه ذخیره می‌کند.

23
00:01:46,636 --> 00:01:50,945
‫اما اگر ویندوز تصمیم بگیرد که پروسه
‫برنامه شما را پس از تعلیق کاملا
‫خاتمه دهد

24
00:01:51,013 --> 00:01:55,853
‫پس از اجرای مجدد برنامه نیاز خواهید
‫داشت تا حالات اشیاء رابط کاربری را
‫مجددا احیاء نمائید.

25
00:01:55,899 --> 00:02:01,152
‫مایکروسافت به این حالت انتقالی،
‫Session نام داده است.

26
00:02:01,152 --> 00:02:05,208
‫و این مورد به اندازه اطلاعاتی که
‫برنامه در حال پردازش آن‌ها است
‫مهم نیست.

27
00:02:05,622 --> 00:02:16,282
‫شاید برای یک کاربر آنچنان اهمیت نداشته
‫باشد که موقعیت قبلی او در رابط
‫کاربری کجا بوده است، اما از دست
‫دادن متن در حال ویرایش، برای او
‫بسیار ناخوشایند خواهد بود.

28
00:02:16,430 --> 00:02:22,500
‫بنابراین در روال رویدادگران تعلیق برنامه، حق
‫تقدم ذخیره سازی اطلاعات کاربر بالاتر خواهد ‫بود.

29
00:02:22,566 --> 00:02:26,658
‫و تنها زمانی باید به ذخیره سازی
‫حالات Session پرداخت که اطلاعات
‫مهم‌تر ذخیره شده باشند.

30
00:02:26,701 --> 00:02:29,597
‫به خاطر داشته باشید که تنها 5
‫ثانیه زمان جهت انجام کل این عملیات
‫در اختیار خواهیم داشت.

31
00:02:29,850 --> 00:02:33,756
‫بنابراین مهم‌ترین کارها را باید در
‫ابتدا انجام داد، پیش از اینکه وارد
‫حالت تعلیق شویم.

32
00:02:34,006 --> 00:02:40,113
‫در اینجا نیاز خواهد بود تا از
‫کلمه کلیدی await استفاده شود که به
‫این ترتیب کل متد را نیز باید
‫async معرفی کرد.

33
00:02:40,466 --> 00:02:47,839
‫و تنها پس از ذخیره سازی اطلاعات
‫کاربر، از کلاس کمکی SessionRespository
‫جهت ذخیره سازی اطلاعات جلسه کاری
‫کاربر استفاده خواهیم نمود.

34
00:02:48,217 --> 00:02:54,416
‫هر دوی این اعمال، غیرهمزمان هستند زیرا
‫باید اطلاعاتی را در فایل سیستم ذخیره ‫نمایند.

35
00:02:54,465 --> 00:02:59,709
‫و این اعمال اندکی آهسته می‌باشند؛
‫بنابراین اجازهٔ انجام آن‌ها را
‫در ترد رابط کاربری نخواهیم داشت.

36
00:02:59,991 --> 00:03:04,654
‫اگر این دو متد async را بدون
‫کلمه کلیدی await فراخوانی کنم

37
00:03:04,684 --> 00:03:07,120
‫این دو متد به موازات هم اجرا
‫خواهند شد که این حالت مد نظر
‫ما نیست.

38
00:03:07,254 --> 00:03:12,772
‫زیرا نیاز داریم تا اطلاعات مهم‌تر ‫کاربر
‫را در ابتدا به نحو مطمئنی
‫ذخیره نمائیم.

39
00:03:13,146 --> 00:03:19,378
‫همچنین دلیل دیگری نیز برای عدم شروع
‫به اجرای این دو کار و سپس فراموش
‫کردن آن‌ها وجود دارد

40
00:03:19,618 --> 00:03:22,053
‫نیاز داریم به ویندوز اعلام کنیم که
‫چه زمانی کار ما خاتمه یافته است.

41
00:03:22,127 --> 00:03:30,207
‫و پس از پایان این متد، ویندوز فرض
‫خواهد کرد که برنامه جهت تعلیق
‫آماده ‫شده است.

42
00:03:30,599 --> 00:03:33,573
‫و به این ترتیب با اجرای موازی دو عمل
‫یاد شده، دیگر تمام 5 ‫ثانیه
‫مقرر را دریافت نخواهیم کرد.

43
00:03:33,982 --> 00:03:39,118
‫زیرا با اجرای موازی این دو قطعه کار،
‫پیش از اتمام عملیات، متد رویدادگردان
‫تعلیق برنامه خاتمه ‫خواهد یافت.

44
00:03:39,347 --> 00:03:43,881
‫اگر با مفاهیم async و await سی
‫شارپ آشنایی ندارید

45
00:03:44,213 --> 00:03:48,566
‫سایت پلورال سایت، دوره ای ویژه را
‫به این موضوع اختصاص داده است.

46
00:03:48,742 --> 00:03:51,838
‫اما بطور خلاصه با استفاده از واژه
‫کلیدی await

47
00:03:51,910 --> 00:03:54,865
‫متد async بلافاصله از سر راه کنار خواهد رفت

48
00:03:54,918 --> 00:04:00,949
‫و کدهای ادامه برنامه توسط کامپایلر به یک
‫Callback تبدیل می‌شوند که در آینده
‫فراخوانی خواهند گشت.

49
00:04:01,298 --> 00:04:03,588
‫بنابراین اکنون مشکلی را خواهیم داشت.

50
00:04:03,897 --> 00:04:07,754
‫من شروع به ذخیره اطلاعات کاربر در
‫فایل سیستم کرده ام

51
00:04:08,154 --> 00:04:14,450
‫اما به کمک این واژه کلیدی await
‫متد فراخوان عملیات بلافاصله
‫از سر راه کنار رفته و به این ترتیب ویندوز
‫فرض خواهد کرد که کار تمام شده ‫است.

52
00:04:14,554 --> 00:04:18,669
‫بنابراین نیاز است به ویندوز اعلام کنیم
‫که کاری را آغاز کرده ایم و
‫در حال انجام است.

53
00:04:18,821 --> 00:04:30,118
‫برای انجام اینکار نیاز است متد
‫GetDeferral شیء
‫e. SuspendingOperation را
‫فراخوانی کنیم.

54
00:04:30,118 --> 00:04:33,469
‫که یک شیء SusspendingDefferal را
‫باز می‌گرداند.

55
00:04:33,581 --> 00:04:38,851
‫پس از پایان ذخیره سازی اطلاعات و
‫حالت برنامه

56
00:04:39,107 --> 00:04:42,489
‫متد Complete شیء defferal تعریف شده
‫را فراخوانی کرده

57
00:04:42,683 --> 00:04:46,843
‫تا به این ترتیب به ویندوز اعلام
‫کنیم که برنامه ما اکنون جهت تعلیق
‫آماده است.

58
00:04:47,021 --> 00:04:48,774
‫و اگر ضرورت دارد، آن را خاتمه ‫دهد.

59
00:04:49,104 --> 00:04:57,785
‫ضمنا باید درنظر داشت که به کمک
‫این متد زمان بیشتری را نمی‌توان
‫خرید و دقیقا سر 5 ثانیه برنامه
‫تحت هر شرایطی معلق خواهد شد.

60
00:04:58,146 --> 00:05:06,696
‫این متد تنها پیش از این 5
‫ثانیه امکان معلق سازی را مهیا کرده،
‫پیش از اینکه ویندوز تصور کند واقعا
‫برنامه کارش را به پایان رسانده است.

61
00:05:06,953 --> 00:05:10,122
‫اجازه دهید تا این موارد را در
‫عمل مشاهده کنیم.

62
00:05:10,163 --> 00:05:14,945
‫برای شروع برنامه را خارج از دیباگر
‫اجرا می‌کنم.

63
00:05:15,040 --> 00:05:18,749
‫به این ترتیب برنامه اجرا شده و
‫می توان با آن تعامل داشت.

64
00:05:19,134 --> 00:05:21,792
‫زمانیکه برنامه باز است، به
‫دسکتاپ سوئیچ می‌کنم.

65
00:05:22,090 --> 00:05:26,231
‫اگر Task Manager را باز کنم، امکان
‫مشاهده برنامه من را خواهید داشت.

66
00:05:26,570 --> 00:05:28,665
‫و اگر چند ثانیه صبر کنیم

67
00:05:28,977 --> 00:05:32,476
‫عاقبت به حالت تعلیق وارد خواهد شد.

68
00:05:32,604 --> 00:05:37,121
‫که این مورد کاملا در Task Manager
‫نیز در ستون Status برنامه نمایش
‫داده شده است.

69
00:05:37,287 --> 00:05:44,895
‫در این حالت تعلیق، شاید نیاز داشته باشید
‫که کدهای در حال اجرا را دیباگ ‫کنید

70
00:05:44,896 --> 00:05:47,827
‫بنابراین برنامه را از طریق Task Manager
‫خاتمه داده

71
00:05:47,943 --> 00:05:49,240
‫تا بتوانیم آن را از طریق ویژوال
‫استودیو اجرا کنیم

72
00:05:49,609 --> 00:05:52,433
‫یک break point را در ابتدای متد
‫Suspending خود قرار می‌دهم

73
00:05:52,556 --> 00:05:55,144
‫اینبار برنامه را از به کمک دیباگر
‫ویژوال استودیو اجرا می‌کنم

74
00:05:55,288 --> 00:06:02,675
‫برنامه اجرا شده و پس از اجرا،
‫می توانم با آن تعامل داشته باشم

75
00:06:03,029 --> 00:06:04,620
‫سپس به دسکتاپ سوئیچ می‌کنم

76
00:06:04,705 --> 00:06:08,105
‫به Task Manager مراجعه کرده و صبر
‫می کنم تا برنامه در حالت تعلیق
‫قرار گیرد.

77
00:06:08,525 --> 00:06:12,104
‫هرچند اینبار باید مدت زیادی را
‫صبر ‫کرد.

78
00:06:12,203 --> 00:06:13,915
‫البته مدت بسیار زیادی را!

79
00:06:14,163 --> 00:06:18,660
‫زیرا ویژوال استودیو معلق سازی برنامه را
‫غیرفعال می‌کند.

80
00:06:19,030 --> 00:06:20,456
‫و برای اینکار علت معقولی را نیز ‫دارد.

81
00:06:20,797 --> 00:06:23,184
‫مگر اینکه چند مونیتور را داشته باشید

82
00:06:23,265 --> 00:06:28,362
‫در غیراینصورت باید از برنامه به ویژوال
‫استودیو سوئیچ کرد و

83
00:06:28,568 --> 00:06:37,236
‫تنها 5 ثانیه فرصت دیباگ برنامه را
‫درون ویژوال استودیو خواهید داشت

84
00:06:37,295 --> 00:06:39,341
‫که آنچنان خوشایند نیست.

85
00:06:39,560 --> 00:06:45,410
‫بنابراین جهت سهولت دیباگ، ویندوز
‫برنامه‌های ‫در حال دیباگ را معلق نمی‌کند.

86
00:06:45,523 --> 00:06:53,073
‫این عالی است، بجز جهت کدهایی که
‫قرار است در متد Suspending ما
‫دیباگ شوند

87
00:06:53,193 --> 00:06:54,940
‫اما برای این مورد نیز تمهیداتی
‫اندیشیده شده است.

88
00:06:55,195 --> 00:07:00,931
‫منوی دیباگ ویژوال استودیو، امکاناتی را دقیقا
‫برای این سناریو تدارک دیده است.

89
00:07:01,178 --> 00:07:02,767
‫گزینهٔ Trigger Suspend

90
00:07:02,803 --> 00:07:05,060
‫پروسه تعلیق را آغاز خواهد کرد

91
00:07:05,211 --> 00:07:08,636
‫به این ترتیب امکان دیباگ کدها در
‫روال رویدادگردان Suspending برنامه
‫میسر خواهد شد.

92
00:07:08,858 --> 00:07:18,091
‫و گزینهٔ Trigger Resume ، حالت
‫بازیابی از تعلیق را سبب می‌گردد.

93
00:07:18,092 --> 00:07:21,324
‫اکنون اگر گزینهٔ Trigger Suspend
‫را انتخاب کنم

94
00:07:21,587 --> 00:07:24,748
‫به break point ابتدای متد رویدادگردان
‫تعلیق خود خواهیم رسید

95
00:07:24,929 --> 00:07:27,666
‫و اکنون اگر تمایل داشته باشم،
‫می‌‫توانم شروع به Trace نمایم.

96
00:07:27,773 --> 00:07:32,674
‫فعلا دیباگ را متوقف می‌کنم زیرا
‫می خواهم سایر رویدادهای مرتبط را
‫به شما نمایش دهم.

97
00:07:33,066 --> 00:07:38,480
‫علاوه بر رویداد Suspending امکان مدیریت
‫رویداد Resuming نیز وجود دارد

98
00:07:38,531 --> 00:07:41,900
‫البته ممکن است نیازی نباشد تا در
‫روال رویدادگردان از سرگیری مجدد
‫کاری را ‫انجام داد

99
00:07:42,036 --> 00:07:53,409
‫در صورتیکه این روال فراخوانی گردد، به
‫این معنا است که پس از تعلیق
‫برنامه، ویندوز برنامه را خاتمه نداده است
‫و اکنون کاربر جهت از سرگیری مجدد
‫کار به آن رجوع نموده است.

100
00:07:53,729 --> 00:07:57,461
‫این برنامه هنوز یک برنامه ویندوز است
‫و به همراه یک سری اطلاعات ذخیره
‫شده در حافظه

101
00:07:57,499 --> 00:08:00,285
‫بنابراین در این حالت همه چیز همانند
‫پیش از تعلیق به نظر خواهد رسید.

102
00:08:00,474 --> 00:08:06,712
‫بنابراین در تئوری نیازی نیست تا در
‫این روال کاری را جهت بازگردان برنامه
‫به حالت قبلی خود انجام داد

103
00:08:06,713 --> 00:08:08,271
‫این برنامه هم اکنون در حالت قبلی
‫خود قرار گرفته است.

104
00:08:08,459 --> 00:08:13,432
‫هدف اصلی وجود این رویداد، به روز
‫رسانی وضعیت برنامه است.

105
00:08:13,468 --> 00:08:17,773
‫اگر برنامه View ایی را جهت نمایش
‫اطلاعات دریافتی از اینترنت نمایش می‌دهد.

106
00:08:17,927 --> 00:08:21,772
‫مانند نمایش فعالیت‌های اخیر یک کاربر
‫در سایت‌های اجتماعی

107
00:08:21,870 --> 00:08:26,264
‫بسیار محتمل است که این اطلاعات در
‫حین تعلیق برنامه تغییر کرده باشند

108
00:08:26,410 --> 00:08:32,943
‫بنابراین پس از مدت زمانی نیاز خواهید
‫داشت تا جدیدترین اطلاعات را مجددا از
‫وب دریافت نمائید.

109
00:08:33,064 --> 00:08:40,472
‫و بدیهی است این عملیات از برنامه‫ای
‫به برنامه دیگر متفاوت خواهد بود
‫و تشخیص وضعیت جاری به عهده شما ‫است.

110
00:08:40,591 --> 00:08:47,461
‫برای مثال اگر برنامه شما کارش نمایش
‫وضعیت هوا است و برنامه تنها 10
‫دقیقه است که معلق شده، به روز
‫رسانی اطلاعات آن منفعتی را به همراه
‫نخواهد داشت.

111
00:08:47,703 --> 00:08:54,587
‫و البته اگر برنامه مثلا یک ساعت معلق
‫شود شاید این به روز رسانی ارزشمند ‫باشد
‫و همچنین نمایش اطلاعات قبلی نیز
‫مشکلی را به همراه نخواهد داشت.

112
00:08:54,996 --> 00:09:03,678
‫و یا اگر برنامه به مدت یک
‫روز در حافظه باقیمانده باشد، اطلاعات آن
‫کاملا منقضی شده و بهتر است که
‫اصلا به کاربر نمایش داده نشود.

113
00:09:03,885 --> 00:09:09,104
‫و بدیهی است منطق تصمیم گیری در
‫این مورد از هر برنامه نسبت به
‫برنامه دیگری متفاوت خواهد بود.

114
00:09:09,198 --> 00:09:16,587
‫در این دمو فرض بر این است
‫که عملیات به روز رسانی رابط کاربری
‫توسط WinRT انجام خواهد شد و آن
‫را پیاده سازی نخواهیم کرد.

115
00:09:16,625 --> 00:09:22,603
‫بنابراین تا اینجا رخدادهای مرتبط با تعلیق
‫و از سرگیری مجدد را بررسی کردیم

116
00:09:22,984 --> 00:09:26,418
‫اما اگر برنامه پس از تعلیق خاتمه
‫یابد چطور؟

117
00:09:26,682 --> 00:09:32,509
‫بدیهی است که برای این حالت رخدادی
‫را دریافت نخواهید کرد، زیرا پس از
‫تعلیق خاتمه یافته و کدی را نمی‌تواند اجرا کند

118
00:09:32,767 --> 00:09:35,587
‫و ویندوز پیش از خاتمه برنامه اخطاری
‫را صادر نخواهد کرد.

119
00:09:35,632 --> 00:09:39,341
‫این روال رویدادگردان Suspending
‫ممکن است آخرین رویدادی باشد که
‫برنامه به خود می‌بیند.

120
00:09:39,715 --> 00:09:46,075
‫اما اگر برنامه مجددا اجرا شود، می‌‫تواند
‫دریابد که پیشتر به چه نحوی
‫خاتمه یافته است.

121
00:09:46,135 --> 00:09:50,244
‫عاقبت کاربر ممکن است پس از خاتمه
‫برنامه توسط ویندوز به آن بازگردد

122
00:09:50,656 --> 00:09:55,961
‫و در این حالت، در روال OnLaunched
‫کلاس App با بررسی آرگومان‌های ‫آن
‫می‌توان به این امر پی ‫برد.

123
00:09:56,304 --> 00:10:01,068
‫آرگومان این متد حاوی خاصیتی است به
‫نام PreviousExecutionState

124
00:10:01,354 --> 00:10:05,749
‫این خاصیت وضعیت برنامه را پیش از
‫اجرا مشخص می‌کند.

125
00:10:05,843 --> 00:10:12,081
‫و چهار حالت مختلف را می‌تواند
‫داشته باشد

126
00:10:12,081 --> 00:10:18,026
‫برای اولین بار اجرای برنامه حالت
‫NotRunning بازگشت داده می‌شود.

127
00:10:18,389 --> 00:10:25,343
‫حالت بعدی یعنی Running مشخص می‌کند
‫که برنامه پیش از اجرای مجدد برنامه
‫در حال اجرا بوده است.

128
00:10:25,449 --> 00:10:34,082
‫در ویندوز 8، برنامه فقط از طریق
‫صفحه آغازین ویندوز اجرا نمی‌شود بلکه
‫برای مثال از طریق گزینهٔ جستجو
‫نیز ممکن است در حال اجرا بوده ‫باشد

129
00:10:34,349 --> 00:10:37,353
‫بنابراین دریافت حالت Running نباید زیاد
‫تعجب برانگیز باشد

130
00:10:37,377 --> 00:10:54,666
‫دو حالت دیگر یعنی Suspended و
‫Terminated مشخص می‌کنند که برنامه پیش
‫از اجرای مجدد در حالت تعلیق قرار
‫داشته یا اینکه کلا خاتمه یافته است
‫و اکنون زمان مناسبی است برای احیای
‫حالت پیشین آن.

